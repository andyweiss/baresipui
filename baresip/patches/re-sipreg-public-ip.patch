diff --git a/include/re_sip.h b/include/re_sip.h
index bd3c4c9..605c996 100644
--- a/include/re_sip.h
+++ b/include/re_sip.h
@@ -458,3 +458,8 @@ int sip_uas_auth_print(struct re_printf *pf,
 		       const struct sip_uas_auth *auth);
 int sip_uas_auth_check(struct sip_uas_auth *auth, const struct sip_msg *msg,
 		       sip_uas_auth_h *authh, void *arg);
+
+
+/* Public IP for NAT traversal (learned from Via received parameter) */
+void sip_set_public_addr(const struct sa *addr);
+const struct sa *sip_get_public_addr(void);
diff --git a/src/sip/sip.c b/src/sip/sip.c
index 9e5649c..4007ac8 100644
--- a/src/sip/sip.c
+++ b/src/sip/sip.c
@@ -326,3 +326,20 @@ struct sip_conncfg *sip_conncfg_find(struct sip *sip,
 
 	return NULL;
 }
+
+/* Public IP storage for NAT traversal */
+static struct sa global_public_addr;
+static bool has_global_public_addr = false;
+
+void sip_set_public_addr(const struct sa *addr)
+{
+	if (addr && sa_isset(addr, SA_ADDR)) {
+		sa_cpy(&global_public_addr, addr);
+		has_global_public_addr = true;
+	}
+}
+
+const struct sa *sip_get_public_addr(void)
+{
+	return has_global_public_addr ? &global_public_addr : NULL;
+}
diff --git a/src/sipreg/reg.c b/src/sipreg/reg.c
index ca87884..76d4e8a 100644
--- a/src/sipreg/reg.c
+++ b/src/sipreg/reg.c
@@ -51,6 +51,8 @@ struct sipreg {
 	char *params;
 	int regid;
 	uint16_t srcport;
+	struct sa public_addr;
+	bool has_public_addr;
 };
 
 
@@ -225,6 +227,16 @@ static void response_handler(int err, const struct sip_msg *msg, void *arg)
 
 	case 401:
 	case 407:
+		/* Extract public IP from Via received parameter */
+		{
+			struct pl received;
+			if (0 == msg_param_decode(&msg->via.params, "received", &received)) {
+				if (0 == sa_set(&reg->public_addr, &received, sa_port(&reg->laddr))) {
+					reg->has_public_addr = true;
+					sip_set_public_addr(&reg->public_addr);
+				}
+			}
+		}
 		if (reg->ls.failc > 1 && last_scode == msg->scode) {
 			reg->failc++;
 			goto out;
@@ -307,7 +319,12 @@ static int send_handler(enum sip_transp tp, struct sa *src,
 	if (reg->srcport && tp != SIP_TRANSP_UDP)
 		sa_set_port(src, reg->srcport);
 
-	reg->laddr = *src;
+	/* Use public IP for Contact if available */
+	if (reg->has_public_addr) {
+		reg->laddr = reg->public_addr;
+	} else {
+		reg->laddr = *src;
+	}
 	err = mbuf_printf(mb, "Contact: <sip:%s@%J%s%s%s>;expires=%u%s%s",
 			  reg->cuser, &reg->laddr, sip_transp_param(reg->tp),
 			  reg->cparams ? ";" : "",
@@ -510,7 +527,7 @@ int sipreg_set_rwait(struct sipreg *reg, uint32_t rwait)
  */
 const struct sa *sipreg_laddr(const struct sipreg *reg)
 {
-	return reg ? &reg->laddr : NULL;
+	return reg ? (reg->has_public_addr ? &reg->public_addr : &reg->laddr) : NULL;
 }
 
 
diff --git a/src/sipsess/connect.c b/src/sipsess/connect.c
index 9a3f234..ce3d1bb 100644
--- a/src/sipsess/connect.c
+++ b/src/sipsess/connect.c
@@ -38,7 +38,16 @@ static int send_handler(enum sip_transp tp, struct sa *src,
 			return err;
 	}
 
-	sip_contact_set(&contact, sess->cuser, src, tp);
+	/* Use public IP for Contact if available */
+	const struct sa *contact_addr = sip_get_public_addr();
+	if (contact_addr && sa_isset(contact_addr, SA_ADDR)) {
+		struct sa pub_with_port;
+		sa_cpy(&pub_with_port, contact_addr);
+		sa_set_port(&pub_with_port, sa_port(src));
+		sip_contact_set(&contact, sess->cuser, &pub_with_port, tp);
+	} else {
+		sip_contact_set(&contact, sess->cuser, src, tp);
+	}
 	err = mbuf_printf(mb, "%H", sip_contact_print, &contact);
 	if (err)
 		goto out;
diff --git a/src/sipsess/reply.c b/src/sipsess/reply.c
index df73d32..1941119 100644
--- a/src/sipsess/reply.c
+++ b/src/sipsess/reply.c
@@ -141,7 +141,16 @@ int sipsess_reply_2xx(struct sipsess *sess, const struct sip_msg *msg,
 	if (non_invite && sess->neg_state != SDP_NEG_REMOTE_OFFER)
 		desc = NULL;
 
-	sip_contact_set(&contact, sess->cuser, &msg->dst, msg->tp);
+	/* Use public IP for Contact if available */
+	const struct sa *contact_addr = sip_get_public_addr();
+	if (contact_addr && sa_isset(contact_addr, SA_ADDR)) {
+		struct sa pub_with_port;
+		sa_cpy(&pub_with_port, contact_addr);
+		sa_set_port(&pub_with_port, sa_port(&msg->dst));
+		sip_contact_set(&contact, sess->cuser, &pub_with_port, msg->tp);
+	} else {
+		sip_contact_set(&contact, sess->cuser, &msg->dst, msg->tp);
+	}
 	err = sip_treplyf(non_invite ? NULL : &sess->st,
 			  reply ? &reply->mb : NULL, sess->sip,
 			  msg, true, scode, reason,
@@ -253,7 +262,16 @@ int sipsess_reply_1xx(struct sipsess *sess, const struct sip_msg *msg,
 	reply->sess = sess;
 	reply->scode = scode;
 
-	sip_contact_set(&contact, sess->cuser, &msg->dst, msg->tp);
+	/* Use public IP for Contact if available */
+	const struct sa *contact_addr2 = sip_get_public_addr();
+	if (contact_addr2 && sa_isset(contact_addr2, SA_ADDR)) {
+		struct sa pub_with_port2;
+		sa_cpy(&pub_with_port2, contact_addr2);
+		sa_set_port(&pub_with_port2, sa_port(&msg->dst));
+		sip_contact_set(&contact, sess->cuser, &pub_with_port2, msg->tp);
+	} else {
+		sip_contact_set(&contact, sess->cuser, &msg->dst, msg->tp);
+	}
 	if (reliably) {
 		sess->rel_seq = sess->rel_seq ? sess->rel_seq+1 : rand_u16();
 		reply->rel_seq = sess->rel_seq;
